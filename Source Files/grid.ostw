import "../global.del";
import "../debug.ostw";
import "../Header Files/ui.del";
import "../Header Files/grid.del";
import "../Header Files/controller-puppet model/player_controller.del";


Any createGrapple(in Vector origin, in Vector offset, in Number j):
    CreateBeamEffect(
        LocalPlayer(),
        BeamType.GoodBeam,
        origin,
        origin + offset,
        Color.Black,
        EffectRev.VisibleToAndColor);
void gridConstructor()
{
    for(define i! = 0; i < 6; i++){ //add 6 blank cells for debug purposes
        new Cell(-1,-1); //discard a cell for "null"
    }
    //
    for(define j! = 0; j < GRID_COLUMNS * GRID_ROWS; j++){
        Number x: j%GRID_COLUMNS;
        Number y: RoundToInteger(j/GRID_COLUMNS, Rounding.Down);
        
        grid.cells[j] = new Cell(x,y);
        grid.cells[j].statics = [1]; //TODO load from disk
        grid.cells[j].dynamic = [];
        
        //DEBUG

        Vector bottomCorner! = GRID_BASE + Vector(
            CELL_WIDTH * (j%GRID_COLUMNS), 0, 
            CELL_HEIGHT * RoundToInteger(j/GRID_COLUMNS,Rounding.Down));
        CreateInWorldText(LocalPlayer(),grid.cells[EvaluateOnce(j)],Grid_positionOfCell(grid.cells[EvaluateOnce(j)])
            ,3,Clipping.DoNotClip,InworldTextRev.VisibleToStringAndColor,
            LocalPlayer().playerCells.Contains(grid.cells[EvaluateOnce(j)]) ? CustomColor(EvaluateOnce(j)*10+100, 6, EvaluateOnce(j)*10+100, 100) : CustomColor(1,1,1, 1),
            Spectators.DefaultVisibility);
        createGrapple(bottomCorner, Vector(CELL_WIDTH,0,0), j);
        createGrapple(bottomCorner, Vector(0,0,CELL_HEIGHT), j);
        createGrapple(bottomCorner + Vector(CELL_WIDTH,0,0), Vector(0,0,CELL_HEIGHT), j);
        createGrapple(bottomCorner + Vector(0,0,CELL_HEIGHT), Vector(CELL_WIDTH,0,0), j);
        Wait();
    }
}

Cell Grid_cellFromGridCoord(in Number xcord, in Number ycord){
    return (xcord >= GRID_COLUMNS || xcord < 0 || ycord >= GRID_ROWS || ycord < 0) ? null : grid.cells[xcord + ycord * GRID_COLUMNS];
}

Vector Grid_positionFromGridCoord(in Number xcord, in Number ycord):
   Vector((xcord + 0.5) * CELL_WIDTH, 0, (ycord + 0.5) * CELL_HEIGHT) 
    + GRID_BASE;

Cell Grid_cellByPosition(in Vector inputPosition)
{
    define xcord: RoundToInteger((inputPosition-GRID_BASE).X/CELL_WIDTH,Rounding.Down);
    define ycord: RoundToInteger((inputPosition-GRID_BASE).Z/CELL_HEIGHT,Rounding.Down);
    return Grid_cellFromGridCoord(xcord,ycord);
}

//(grid.cells.IndexOf(cell)%GRID_COLUMNS+0.5)
//(RoundToInteger(grid.cells.IndexOf(cell)/GRID_COLUMNS,Rounding.Down)+0.5)

Vector Grid_positionOfCell(in Cell cell): 
    Grid_positionFromGridCoord(cell.x,cell.y);

void Cell_addProjectile(in Cell cell, in Projectile p){
    grid.cells[cell].dynamic.ModAppend(p);
    foreach(Controller viewer! in cell.viewers){
        Number nullIndex = 0;
        nullIndex = IndexOfArrayValue(renderProjectiles,null);
        if(nullIndex != -1){
            nullIndex = CountOf(renderProjectiles);
            renderProjectiles.Append(p);
            throwError({message: "Expanded renderProjectiles array size",
            source: "grid add (projectile)", severity: EErrorSeverity.WARNING});
        }
        Dictionary<Cell,Number[]>.Set(
            viewer.self.cellProjectiles,/*with key*/ cell,
            viewer.self.cellProjectiles.Get(cell).Append(nullIndex));
    }
}

void Cell_addCreature(in Cell cell, in Creature c){
    grid.cells[cell].dynamic.ModAppend(c);
    foreach(Controller viewer! in cell.viewers){
        Number nullIndex = 0;
        nullIndex = IndexOfArrayValue(renderCreatures,null);
        if(nullIndex != -1){
            nullIndex = CountOf(renderCreatures);
            renderCreatures.Append(c);
            throwError({message: "Expanded renderCreatures array size",
            source: "grid add (creature)", severity: EErrorSeverity.WARNING});
        }
        Dictionary<Cell,Number[]>.Set(
            viewer.self.cellCreatures,/*with key*/ cell,
            viewer.self.cellCreatures.Get(cell).Append(nullIndex));
    }
}


void Cell_removeProjectile(in Cell cell, in Projectile p){
    grid.cells[cell].dynamic.ModRemoveByValue(p);
    foreach(Controller viewer! in cell.viewers){
        Number indexOfRenderData = p.viewerIndex[viewer.self.ID];
        Dictionary<Cell,Number[]>.Set(
            viewer.self.cellProjectiles,/*with key*/ cell,
            viewer.self.cellProjectiles.Get(cell).Remove(indexOfRenderData));
            //remove the given index from the data
        p.viewerIndex[viewer.self.ID] = null;
        if(viewer.self.renderProjectiles[indexOfRenderData] != p){
                throwError({message: $"buffer {viewer.self.renderProjectiles[indexOfRenderData]}  "+
                "overwritten with null caught", source: "Grid_remove: projectile", severity: EErrorSeverity.ERROR});
                Abort();
            }
            viewer.self.renderProjectiles[indexOfRenderData] = null; //removes self from each player's render buffer
    }
}

void Cell_removeCreature(in Cell cell, in Creature c){
    grid.cells[cell].dynamic.ModRemoveByValue(c);
    foreach(Controller viewer! in cell.viewers){
        Number indexOfRenderData = c.viewerIndex[viewer.self.ID];
        Dictionary<Cell,Number[]>.Set(
            viewer.self.cellCreatures,/*with key*/ cell,
            viewer.self.cellCreatures.Get(cell).Remove(indexOfRenderData));
            //remove the given index from the data
        c.viewerIndex[viewer.self.ID] = null;
        if(viewer.self.renderCreatures[indexOfRenderData] != c){
                throwError({message: $"buffer {viewer.self.renderCreatures[indexOfRenderData]}  "+
                "overwritten with null caught", source: "Grid_remove: creature", severity: EErrorSeverity.ERROR});
                Abort();
            }
            viewer.self.renderCreatures[indexOfRenderData] = null; //removes self from each player's render buffer
    }
}

void Grid_moveCreature(in Creature c, in Cell from, in Cell to){
    if(grid.cells[from].dynamic.Contains(c)){
        Cell_removeCreature(from,c);
        Cell_addCreature(to,c);
    }
}

playervar Cell[] cells;


//checkRange(cells,position + Vector(0,0,-CELL_HEIGHT*VIEW_RANGE));
void checkRange(ref Cell[] cellsRef, in Vector pos){
    Cell temp = Grid_cellByPosition(pos);
    if(temp == null || cellsRef.Contains(temp)){
        return;
    }   
    if(cellsRef.Length>0)
        cellsRef.ModAppend(temp);
    else
        cellsRef[0] = temp;
} 

Cell[] getAllCellsInUniformDistanceFromCell(in Cell given, Number distance){
    if(given == null){
        return [];
    }
    Cell[] retCells = [];
    for(define j! = -distance; j <= distance; j++){
       for(define i! = -distance; i <= distance; i++){
            Cell temp = Grid_cellFromGridCoord(given.x+i,given.y+j);
            if (temp != null){
                retCells.ModAppend(temp);
            }
        } 
    }
    return retCells;
}



// void requestCells(ref Any[] arrayPointer, in Cell[] cells){ //moves all the requested cells into playerCells
//     arrayPointer = [];
//     foreach(Cell cell in cells){
//         arrayPointer.ModAppend(cell);
//     }
// }