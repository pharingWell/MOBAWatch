import "../global.del";
import "../debug.ostw";
import "../Header Files/ui.del";
import "../Header Files/grid.del";


Any createGrapple(in Vector origin, in Vector offset, in Number j):
    CreateBeamEffect(
        LocalPlayer(),
        BeamType.GoodBeam,
        origin,
        origin + offset,
        Color.Black,
        EffectRev.VisibleToAndColor);
void gridConstructor()
{
    for(define i! = 0; i < 6; i++){ //add 6 blank cells for debug purposes
        new Cell(-1,-1); //discard a cell for "null"
    }
    //
    for(define j! = 0; j < GRID_COLUMNS * GRID_ROWS; j++){
        Number x: j%GRID_COLUMNS;
        Number y: RoundToInteger(j/GRID_COLUMNS, Rounding.Down);
        
        grid.cells[j] = new Cell(x,y);
        grid.cells[j].statics = [1]; //TODO load from disk
        grid.cells[j].dynamic = [];
        
        //DEBUG

        Vector bottomCorner! = GRID_BASE + Vector(
            CELL_WIDTH * (j%GRID_COLUMNS), 0, 
            CELL_HEIGHT * RoundToInteger(j/GRID_COLUMNS,Rounding.Down));
        CreateInWorldText(LocalPlayer(),grid.cells[EvaluateOnce(j)],positionOfCell(grid.cells[EvaluateOnce(j)])
            ,3,Clipping.DoNotClip,InworldTextRev.VisibleToStringAndColor,
            CustomColor(LocalPlayer().playerCells.Contains(grid.cells[EvaluateOnce(j)])*EvaluateOnce(j)*10+100, 2, EvaluateOnce(j)*10*LocalPlayer().playerCells.Contains(grid.cells[EvaluateOnce(j)]), 100+100*grid.cells[EvaluateOnce(j)].viewers.Contains(LocalPlayer())),
            Spectators.DefaultVisibility);
        createGrapple(bottomCorner, Vector(CELL_WIDTH,0,0), j);
        createGrapple(bottomCorner, Vector(0,0,CELL_HEIGHT), j);
        createGrapple(bottomCorner + Vector(CELL_WIDTH,0,0), Vector(0,0,CELL_HEIGHT), j);
        createGrapple(bottomCorner + Vector(0,0,CELL_HEIGHT), Vector(CELL_WIDTH,0,0), j);
        Wait();
    }
}

void Cell_fromGridCoord(ref Cell cellptr, in Number xcord, in Number ycord){
    Boolean outOfBounds! = (xcord >= GRID_COLUMNS || xcord < 0 || ycord >= GRID_ROWS || ycord < 0);
    if(outOfBounds){
        cellptr = null;
    }else{
        cellptr = grid.cells[xcord + ycord * GRID_COLUMNS];
    }  
}

void Cell_byPosition(ref Cell cellptr, in Vector inputPosition)
{
    Number xcord! = RoundToInteger((inputPosition-GRID_BASE).X/CELL_WIDTH,Rounding.Down);
    Number ycord! = RoundToInteger((inputPosition-GRID_BASE).Z/CELL_HEIGHT,Rounding.Down);
    Cell_fromGridCoord(cellptr, xcord,ycord);
}

//(grid.cells.IndexOf(cell)%GRID_COLUMNS+0.5)
//(RoundToInteger(grid.cells.IndexOf(cell)/GRID_COLUMNS,Rounding.Down)+0.5)

Vector positionFromGridCoord(in Number xcord, in Number ycord):
   Vector((xcord + 0.5) * CELL_WIDTH, 0, (ycord + 0.5) * CELL_HEIGHT) 
    + GRID_BASE;

Vector positionOfCell(in Cell cell): 
    positionFromGridCoord(cell.x,cell.y);

void getAllCellsInUniformDistanceFromCell(ref Cell[] retCells, in Cell given, in Number distance){
    if(given == null){
        return;
    }
    retCells = [];
    for(define j! = -distance; j <= distance; j++){
       for(define i! = -distance; i <= distance; i++){
            Cell temp!;
            Cell_fromGridCoord(temp, given.x+i,given.y+j);
            if (temp != null){
                retCells.ModAppend(temp);
            }
        } 
    }
}



















// void requestCells(ref Any[] arrayPointer, in Cell[] cells){ //moves all the requested cells into playerCells
//     arrayPointer = [];
//     foreach(Cell cell in cells){
//         arrayPointer.ModAppend(cell);
//     }
// }