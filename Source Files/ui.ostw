import "../Header Files/ui.del";
import "../Header Files/state.del";
import "../debug.ostw";
import "../debug.del";
import "../const.del";
import "grid.ostw";
import "render.ostw";


rule: 'Global Render Setup' 
if(gameState[EGamePhase.LOADING] == ELoadingState.RENDER_SETUP)
{
    
    gridConstructor();
    for(define i = 1; i <= RENDER_SIZE; i++){
        Creature creature: LocalPlayer().renderCreatures[EvaluateOnce(i)];
        Number tick: (TotalTimeElapsed()-creature.tickOffset+TICK_MAGIC);

        if(SHOW_ENTITY_PROJECTEDLOC){
            CreateInWorldText(
                creature.visibility ? LocalPlayer() : null,
                creature.appearance,
                creature.position + tick*creature.velocity,
                3, 
                Clipping.DoNotClip, 
                InworldTextRev.VisibleToPositionStringAndColor,
                creature.color, 
                Spectators.DefaultVisibility   
            );
        }
        if(SHOW_ENTITY_TRUELOC){
            CreateInWorldText(
                creature.visibility ? LocalPlayer() : null,
                creature,
                creature.position,
                2, 
                Clipping.DoNotClip, 
                InworldTextRev.VisibleToPositionStringAndColor,
                CustomColor(0,0,0,50), 
                Spectators.DefaultVisibility   
            );
        }
    }
    LogToInspector(TotalTimeElapsed()*1000);
    progressState();
}

rule: 'Player Render Setup'
Event.OngoingPlayer
{
    DisableGameModeHud();
}
globalvar Number VIEW_RANGE = WorkshopSettingInteger("Player Settings","View Range",1,0,6,0);
rule: 'Grid Render Loop'

Event.OngoingPlayer
if(!IsDummyBot(EventPlayer()))
if(gameState[EGamePhase.LOADING] > ELoadingState.RENDER_SETUP)
{
    LOCK = true;
    Cell[] observedCells;
    Cell temp!;
    Cell_byPosition(temp,EventPlayer().Position());
    if(VIEW_RANGE == 0){
        observedCells = [temp];
    }else{   
        getAllCellsInUniformDistanceFromCell(observedCells,temp, VIEW_RANGE);
    }
    Cell[] noLongerObservedCells! = FilteredArray(EventPlayer().playerCells, !ArrayContains(observedCells,ArrayElement()));
    Cell[] newlyObservedCells! = FilteredArray(observedCells, !ArrayContains(EventPlayer().playerCells,ArrayElement()));
    foreach(Cell cell! in noLongerObservedCells){
        foreach(Entity e! in cell.dynamic){
            if(e.subclass == EEntitySubclass.CREATURE){
                removeEntityFromViewer(EventPlayer().renderCreatures,EventPlayer().creatureRenderIndexes,EventPlayer().ID,cell,e);
            }else if(e.subclass == EEntitySubclass.PROJECTILE){
                removeEntityFromViewer(EventPlayer().renderProjectiles,EventPlayer().projectileRenderIndexes,EventPlayer().ID,cell,e);
            }   
        }
        cell.viewers -= EventPlayer();
    }
    
    foreach(Cell cell! in newlyObservedCells){
        cell.viewers += EventPlayer();
        foreach(Entity e! in cell.dynamic){
            if(e.subclass == EEntitySubclass.CREATURE){
                addEntityToViewer(EventPlayer().renderCreatures,EventPlayer().creatureRenderIndexes,EventPlayer().ID,cell,e);
            }else if(e.subclass == EEntitySubclass.PROJECTILE){
                addEntityToViewer(EventPlayer().renderProjectiles,EventPlayer().projectileRenderIndexes,EventPlayer().ID,cell,e);
            }   
        }
    }

//todo: an observable list of cells per team

    EventPlayer().playerCells = observedCells;
    Wait();
    LOCK = false;
    Wait(0.25);
    Loop();
}





