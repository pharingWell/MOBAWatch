import "../global.del";
import "../debug.del";
import "grid.ostw";
import "../Header Files/ui.del";
import "../Header Files/render.del";
import "../Header Files/controller-puppet model/player_controller.del";

rule: 'Global Render Setup' 
if(gameState[EGamePhase.LOADING] == ELoadingState.RENDER_SETUP)
{
    
    async gridConstructor();
    Wait(0.5);
    define i!;
    for(i = 1; i <= TEXT_COUNT; i++){
        Creature creature: LocalPlayer().renderCreatures[EvaluateOnce(i)];
        Number tick: (TotalTimeElapsed()-creature.tickOffset+TICK_MAGIC);

        if(SHOW_ENTITY_PROJECTEDLOC){
            CreateInWorldText(
                creature.visibility ? controllers : null,
                creature.appearance,
                creature.position + tick*creature.velocity,
                TEXT_SIZE, 
                Clipping.DoNotClip, 
                InworldTextRev.VisibleToPositionStringAndColor,
                creature.color, 
                Spectators.DefaultVisibility   
            );
        }
        /* if(SHOW_ENTITY_TRUELOC){ //this should be disabled unless debugging, in which case, TEXT_COUNT should be halved
            CreateInWorldText(
                creature.visibility ? controllers : null,
                creature,
                creature.position,
                TEXT_SIZE, 
                Clipping.DoNotClip, 
                InworldTextRev.VisibleToPositionStringAndColor,
                CustomColor(0,0,0,50), 
                Spectators.DefaultVisibility   
            );
        }*/
    }

    for(i = 1; i < STATICS_COUNT; i++){
        Vector edge_start: LocalPlayer().edgeStarts[EvaluateOnce(i)];
        Vector edge_end: LocalPlayer().edgeEnds[EvaluateOnce(i)];
        CreateBeamEffect(controllers,BeamType.BrigitteFlailChainBeam,edge_start,edge_end,Color.Black,EffectRev.VisibleToPositionAndRadius);
    }
    progressState();
}

rule: 'Grid Render Loop'

Event.OngoingPlayer
if(!IsDummyBot(EventPlayer()))
if(gameState[EGamePhase.LOADING] > ELoadingState.RENDER_SETUP)
if(READY == true)
{
    LOCK = true;
    async updateCells();
    LOCK = false;
    Wait(0.4);
    //Loop();
}


void updateCells() "Update Observed Cells"
{
    Cell[] observedCells;
    getAllCellsOnScreen(observedCells,EventPlayer().cameraPos);
    Cell[] noLongerObservedCells! = FilteredArray(EventPlayer().playerCells, !ArrayContains(observedCells,ArrayElement()));
    Cell[] newlyObservedCells! = FilteredArray(observedCells, !ArrayContains(EventPlayer().playerCells,ArrayElement()));
    if(noLongerObservedCells.Length > 0){
        foreach(Cell cell! in noLongerObservedCells){
        removeAllStaticsInCellFromViewer(EventPlayer(),cell);
        foreach(Entity e! in cell.dynamic){
            if(e.subclass == EEntitySubclass.CREATURE){
                removeEntityFromViewer(EventPlayer().renderCreatures,EventPlayer().creatureRenderIndexes,EventPlayer().ID,cell,e);
            }else if(e.subclass == EEntitySubclass.PROJECTILE){
                removeEntityFromViewer(EventPlayer().renderProjectiles,EventPlayer().projectileRenderIndexes,EventPlayer().ID,cell,e);
            }   
        }
        cell.viewers -= EventPlayer();
    }
    }
    if(newlyObservedCells.Length > 0){
        foreach(Cell cell! in newlyObservedCells){
                addAllStaticsInCellToViewer(EventPlayer(),cell);
                cell.viewers += EventPlayer();
                Number[] creatureRenderTemp = []; //EventPlayer().creatureRenderIndexes
                Number[] projectileRenderTemp = []; //EventPlayer().projectileRenderIndexes
                foreach(Entity e! in cell.dynamic){
                    if(e.subclass == EEntitySubclass.CREATURE){
                        addEntityToViewer(EventPlayer().renderCreatures,creatureRenderTemp,EventPlayer().ID,cell,e);
                    }else if(e.subclass == EEntitySubclass.PROJECTILE){
                        addEntityToViewer(EventPlayer().renderProjectiles,projectileRenderTemp,EventPlayer().ID,cell,e);
                    }
                    else{
                        throwError({message: "can't add entity without subclass",source: "newly observed cells",severity: EErrorSeverity.ERROR});
                    }
                }
                EventPlayer().creatureRenderIndexes[cell.id] = creatureRenderTemp;
                EventPlayer().projectileRenderIndexes[cell.id] = projectileRenderTemp;
        }
    }
//todo: an observable list of cells per team
    EventPlayer().playerCells = observedCells;
    Wait();

}

//ADD

void addEntityToViewer(
    ref Any[] renderBuffer, ref Number[] renderIndexContainer, 
    in Number ID, in Cell cell, in Entity e
){      
    if(e == null){
        return;
    }    
    define indexOfFirstNull! = 1;
    while(renderBuffer[indexOfFirstNull] != null){
        indexOfFirstNull++;
    }
    renderIndexContainer += indexOfFirstNull;
    e.viewerIndex[ID] = indexOfFirstNull;
    renderBuffer[indexOfFirstNull] = e;
}

void addEntityToViewer(Cell cell, Entity e){
    if(e.subclass == EEntitySubclass.CREATURE){
        addEntityToViewer(EventPlayer().renderCreatures,EventPlayer().creatureRenderIndexes[cell.id],EventPlayer().ID,cell,e);
    }else if(e.subclass == EEntitySubclass.PROJECTILE){
        addEntityToViewer(EventPlayer().renderProjectiles,EventPlayer().projectileRenderIndexes[cell.id],EventPlayer().ID,cell,e);
    } 
}

void addEntityToCell(Cell cell, Entity e) "Add Entity To Cell"
{   
    cell.dynamic.ModAppend(e);
    foreach(Player player! in cell.viewers){
        if(e.subclass == EEntitySubclass.CREATURE){
            addEntityToViewer(player.renderCreatures,player.creatureRenderIndexes[cell.id],player.ID, cell, e);
        }else if(e.subclass == EEntitySubclass.PROJECTILE){
            addEntityToViewer(player.renderProjectiles,player.projectileRenderIndexes[cell.id],player.ID, cell, e);
        }
    }
    e.cell = cell;
}

void addAllStaticsInCellToViewer(in Player player, in Cell cell){
    
    Number[] renderIndexesTemp! = [];
    foreach(Statics s in cell.statics){
        define indexOfFirstNull! = 1;
        for(define i! = 0; i < s.points.Length/2; i++){
            while(player.edgeStarts[indexOfFirstNull] != null){
                indexOfFirstNull++;
            }
            player.edgeStarts[indexOfFirstNull] = s.points[i*2]+s.position;
            player.edgeEnds[indexOfFirstNull] = s.points[i*2+1]+s.position;
            renderIndexesTemp += indexOfFirstNull;
            indexOfFirstNull++;
        }
    }
    player.staticsRenderIndexes[cell.id] = renderIndexesTemp;
}

//REMOVE

private void removeEntityFromViewer(
    ref Any[] renderBuffer, ref Number[][] renderIndexContainer,
    in Number ID, in Cell cell, in Entity e
){
    Number indexOfRenderData: e.viewerIndex[ID];
    renderIndexContainer[cell.id] -= indexOfRenderData;
    renderBuffer[indexOfRenderData] = null;
    e.viewerIndex[ID] = null; //must be last
}

private void removeAllStaticsInCellFromViewer(in Player player, in Cell cell){
    for(define i! = 0; i < player.staticsRenderIndexes[cell.id].Length; i++){
        define index: player.staticsRenderIndexes[cell.id][i];
        player.edgeStarts[index] = null;
        player.edgeEnds[index] = null;
    }
    player.staticsRenderIndexes[cell.id] = null;
}

//MOVE

void moveEntityBetweenCells(Entity e, Cell from, Cell to) "move Entity between Cells"
{
    
    Player addEntityTo! = FilteredArray(to.viewers, !from.viewers.Contains(ArrayElement()));
    Player moveEntityBetween = FilteredArray(to.viewers, from.viewers.Contains(ArrayElement()));
    Player removeEntityFrom! = FilteredArray(from.viewers, !to.viewers.Contains(ArrayElement()));
    
    if(from.dynamic.Contains(e)){
        from.dynamic -= e;
    }else{
        throwError({message: $"Tried to move entity {e}  between cells {from}  and {to}", source: "moveEntityBetweenCells", severity: EErrorSeverity.ERROR});
        return;
    }
    foreach(Player p! in addEntityTo){
        if(e.subclass == EEntitySubclass.CREATURE){
            addEntityToViewer(p.renderCreatures,p.creatureRenderIndexes[to.id],p.ID,to,e);
        }else if(e.subclass == EEntitySubclass.PROJECTILE){
            addEntityToViewer(p.renderProjectiles,p.projectileRenderIndexes[to.id],p.ID,to,e);
        }
    }
    foreach(Player p! in moveEntityBetween){
        Number index: e.viewerIndex[p.ID];
        if(e.subclass == EEntitySubclass.CREATURE){
            p.creatureRenderIndexes[from.id] -= index;
            p.creatureRenderIndexes[to.id] += index;
        }else if(e.subclass == EEntitySubclass.PROJECTILE){
            p.projectileRenderIndexes[from.id] -= index;
            p.projectileRenderIndexes[to.id] += index;
        }
    }
    foreach(Player p! in removeEntityFrom){
        if(e.subclass == EEntitySubclass.CREATURE){
            removeEntityFromViewer(p.renderCreatures,p.creatureRenderIndexes,p.ID,from,e);
        }else if(e.subclass == EEntitySubclass.PROJECTILE){
            removeEntityFromViewer(p.renderProjectiles,p.projectileRenderIndexes,p.ID,from,e);
        }
    }
    to.dynamic += e;
    e.cell = to;
}
