import "entity.del";
import "statics.del";
import "render.del";
import "structures.del";
import "model/player_controller.del";
import "../error.ostw";
import "../const.del";
class Cell{
    public Player[] viewers;
    public Entity[] dynamic;
    public Statics[] statics;
    public Number x;
    public Number y;
    public Number id;
    public constructor(in Number x, in Number y){
        this.x = x;
        this.y = y;
        this.id = x+y*GRID_COLUMNS;
        this.viewers = [];
        this.dynamic = [];
        this.statics = [];
    }
}
struct GridStruct{ //only used once
    public Cell[] cells;
}
globalvar GridStruct grid;





Vector positionFromGridCoord(in Number xcord, in Number ycord):
   Vector((xcord + 0.5) * CELL_WIDTH, 0, (ycord + 0.5) * CELL_HEIGHT) 
    + GRID_BASE;

Vector positionOfCell(in Cell cell): 
    positionFromGridCoord(cell.x,cell.y);


void Cell_byPosition(ref Cell cellptr, in Vector inputPosition)
{
    Number xcord! = RoundToInteger((inputPosition-GRID_BASE).X/CELL_WIDTH,Rounding.Down);
    Number ycord! = RoundToInteger((inputPosition-GRID_BASE).Z/CELL_HEIGHT,Rounding.Down);
    Cell_fromGridCoord(cellptr, xcord,ycord);
}

void Cell_fromGridCoord(ref Cell cellptr, in Number xcord, in Number ycord){
    Boolean outOfBounds! = (xcord >= GRID_COLUMNS || xcord < 0 || ycord >= GRID_ROWS || ycord < 0);
    if(outOfBounds){
        cellptr = null;
    }else{
        cellptr = grid.cells[xcord + ycord * GRID_COLUMNS];
    }  
}